#!/usr/bin/env bash
############################################################
set -eu
############################################################
trap 'echo "Error on line $LINENO of $(basename($0))"' ERR
############################################################
: <<-'EOF'
CHANGELOG:
0.0.1: 2023-09-15
    - initial version
TODO:
- [ ] Logging
EOF
############################################################ Variables
EXECUTABLE_NAME=xec
BINARY_DIR="./bin"
############################################################ Overrides
DEBUG=0
############################################################ Defaults
export DEBUG=${DEBUG:-0}
export VERBOSE=${VERBOSE:-1}
############################################################ Console Output
console_marks_check='\xE2\x9C\x94'
console_marks_cross='\xE2\x9D\x8C'
console_marks_arrow='\xE2\x9E\xA1'

console_marks_success=${console_marks_check}
console_marks_error=${console_marks_cross}

COLOR_SUCCESS='82'
COLOR_FAILURE='160'
COLOR_NORMAL='241'
COLOR_INFO='81'
COLOR_WARNING='226'
COLOR_RESET='\033[0m'
COLOR_BACKGROUND='0'

out() {
    SEVERITY=${1:-"info"}
    FOREGROUND_COLOR=${2:-$COLOR_NORMAL}
    # BACKGROUND_COLOR=${3:-$COLOR_BACKGROUND}
    SYMBOL=${4:-$console_marks_arrow}
    if [[ $VERBOSE -eq 1 ]]; then
        echo -e -n "\033[38;5;${FOREGROUND_COLOR}m"
        echo -e -n "[${SEVERITY}]"
        for message in "${@:4}"; do
            echo -e "${SYMBOL} ${message}${COLOR_RESET}"
        done
        echo -e "${COLOR_RESET}"
    fi
}
info() {
    out "info" "${COLOR_INFO}" "${COLOR_BACKGROUND}" "${console_marks_arrow}" "$@"
}
failure() {
    out "failure" "${COLOR_FAILURE}" "${COLOR_BACKGROUND}" "${console_marks_error}" "$@"
    exit 1
}
warning() {
    out "warning" "${COLOR_WARNING}" "${COLOR_BACKGROUND}" "${console_marks_arrow}" "$@"
}
success() {
    out "success" "${COLOR_SUCCESS}" "${COLOR_BACKGROUND}" "${console_marks_success}" "$@"
}
############################################################
getInput() {
    \read -r -p "$1" input
    echo -n "${input}"
}
############################################################
# shellcheck disable=SC2120
confirmToContinue() {
    prompt=${1:-"Continue? [yes/N]"}
    \read -r -p "$prompt" input
    if [[ "$input" != "yes" ]]; then
        echo "Aborted."
        exit 1
    fi
}
############################################################
# Checks for requirements for given type
# Globals:
#   None
# Arguments:
#   1) "required_list": List of requirement names
#   2) "required_type": Type of requirement, can be one of: command, function, variable, file, default is command.
# Outputs:
#   None
############################################################
checkRequirements() {
    # required_list is a list of required commands/executables seperated by space, e.g. "kubectl helm".
    required_list=${1:?"required_list variable is required"}
    # required_type can be one of command, function, or variable. Default is command.
    required_type=${2:-"command"}

    # Check if required binaries exists in the system.
    for required in $required_list; do
        if [ "$required_type" = "command" ]; then
            if ! command -v "$required" >/dev/null 2>&1; then
                failure "ERROR: $required is not installed. Please install and try again."
            fi
        elif [ "$required_type" = "function" ]; then
            if ! declare -f "$required" >/dev/null; then
                failure "ERROR: $required function is not defined. Please define it and try again."
            fi
        elif [ "$required_type" = "variable" ]; then
            if ! declare -p "$required" >/dev/null; then
                failure "ERROR: $required variable is not defined. Please define it and try again."
            fi
        elif [ "$required_type" = "file" ]; then
            if [ ! -f "$required" ]; then
                failure "ERROR: $required file is not found. Please create it and try again."
            fi
        else
            failure "ERROR: $required_type is not a valid required type. Please use command, function, or variable."
        fi
    done
}
###########################################################
container.build() {
    # For future use:
    GIT_COMMIT_SHORT="$(git rev-parse --short HEAD)"
    CONTAINER_HASH="${GIT_COMMIT_SHORT}"

    docker buildx build \
        --load \
        --platform linux/amd64 \
        --tag leventogut/xec:"${CONTAINER_HASH}" \
        --tag leventogut/xec:"latest" .
}
############################################################
build() {
    build_per_platform "linux" "amd64"
    build_per_platform "darwin" "amd64"
    build_per_platform "darwin" "arm64"
}
build_per_platform() {
    GOOS=${1:-darwin}
    GOARCH=${2:-arm64}
    go build -o ${BINARY_DIR}/${EXECUTABLE_NAME}-${GOOS}-${GOARCH} .
}
############################################################
run() {
    export XEC_ENV_KEY=XEC_ENV_VALUE
    export XEC_SECRET_KEY=XEC_SECRET_VALUE
    go run main.go $@
}
############################################################
isCommand() {
    name="$1"
    # ref: Display the path to the executable or the alias definition of a specific command
    output=$(command -v "$name")
    commandStatusCode=$?
    if [ $commandStatusCode = 0 ] && ! echo "$output" | grep -q "/" >/dev/null 2>&1; then
        return 0
    fi
    return 1
}
############################################################
main() {
    checkRequirements "git go" "command"
    commandInput="${1:-usage}"
    case $commandInput in
    "build")
        shift
        build $@
        ;;
    "run")
        shift
        run $@
        ;;
    "container-build")
        shift
        container.build $@
        ;;
    "dev")
        shift
        run.dev $@
        ;;
    "exec")
        shift
        container.exec $@
        ;;
    *)
        usage
        ;;
    esac
}
############################################################
main "$@"
